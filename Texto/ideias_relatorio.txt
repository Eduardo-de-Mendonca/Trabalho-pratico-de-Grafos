Coisas a colocar no relatório

Uma cópia inteira de Graph.h:
    Não tem as implementações, mas dá a melhor ideia possível de como fizemos as coisas

Decisões de projeto relevantes:
    Usamos a estutura de dados std::vector para tudo, em vez de ter vetor e lista separados
        É um vetor, então serve para quando precisamos de vetor
        Permite que adicionemos no fim com complexidade amortizada O(1), o que nos atende nas situações que poderiam demandar o uso de uma lista.

    Ignoramos a primeira entrada dos vetores de adjacência, além da primeira linha e da primeira coluna da matriz de adjacência
        Assim, os vértices vão de 1 a n inclusive, e não há necessidade de decrementar ou incrementar ao receber o input ou dar o output

    Nos métodos max_dist, bfs, dfs, dist, diameter, approx_diameter...
        Usamos -1 para representar "infinito" (distância entre vértices não conectados)

Decisões de projeto menos relevantes, mas que pode ser útil comentar se quiser
    Para o cálculo de componentes conexas:
        Temos um método privado connected_component_vector, que separa o grafo em componentes, mas sem atribuir os índices das componentes em ordem decrescente de tamanho (a componente conexa 0 pode ser menor que a 1, por exemplo), e faz isso em O(n + m)

        Temos um método público connected_components que separa o grafo em componentes conexas atribuindo os índices em ordem decrescente de tamanho. Em compensação, a complexidade é pior (O(m + n log n)), devido à ordenação

        Temos um método público connected_component_info que calcula a quantidade de componentes conexas e os tamanhos da maior e da menor em O(n + m). Ele faz isso chamando apenas connected_component_vector, sem chamar connected_components, para não precisar fazer ordenaçãos